@typeparam TItem
@typeparam TValue
@using System.Timers
@inject IJSRuntime JSRuntime

<div class="searchable-select @CssClass">
    <Dropdown>
        <DropdownToggleButton Color="ButtonColor.Light" disabled="@IsDisabled">
            @if (SelectedValue != null && Items != null)
            {
                var selectedItem = Items.FirstOrDefault(item => ValueSelector(item)?.Equals(SelectedValue) == true);
                if (selectedItem != null)
                {
                    <span>@DisplaySelector(selectedItem)</span>
                }
                else
                {
                    <span class="text-muted">@Placeholder</span>
                }
            }
            else
            {
                <span class="text-muted">@Placeholder</span>
            }
        </DropdownToggleButton>
        <DropdownMenu>
            <div class="p-2">
                <input type="text" class="form-control" placeholder="Search..." @bind="searchTerm" @bind:event="oninput" />
            </div>
            @if (isLoading)
            {
                <div class="dropdown-item text-center">
                    <Spinner />
                    <span class="ms-2">Loading...</span>
                </div>
            }
            else if (!filteredItems.Any())
            {
                <div class="dropdown-item text-muted text-center">
                    @(string.IsNullOrWhiteSpace(searchTerm) ? "No items available" : "No items found")
                </div>
            }
            else
            {
                <div class="searchable-select-items">
                    @foreach (var item in filteredItems.Take(displayCount))
                    {
                        <DropdownItem @onclick="() => SelectItem(item)">
                            @DisplaySelector(item)
                        </DropdownItem>
                    }

                    @if (filteredItems.Count() > displayCount)
                    {
                        <div class="dropdown-item text-center">
                            <Button Color="ButtonColor.Primary" Size="ButtonSize.Small" @onclick="LoadMore">
                                Load More (@(filteredItems.Count() - displayCount) remaining)
                            </Button>
                        </div>
                    }
                </div>
            }
            @if (AllowClear && SelectedValue != null)
            {
                <DropdownDivider />
                <DropdownItem @onclick="ClearSelection">
                    <Icon Name="IconName.XCircle" />
                    Clear Selection
                </DropdownItem>
            }
        </DropdownMenu>
    </Dropdown>
</div>

<style>
    .searchable-select-items {
        max-height: 240px;
        overflow-y: auto;
    }
</style>

@code {
    [Parameter, EditorRequired] public IEnumerable<TItem>? Items { get; set; }
    [Parameter, EditorRequired] public Func<TItem, TValue> ValueSelector { get; set; } = default!;
    [Parameter, EditorRequired] public Func<TItem, string> DisplaySelector { get; set; } = default!;
    [Parameter] public TValue? SelectedValue { get; set; }
    [Parameter] public EventCallback<TValue?> SelectedValueChanged { get; set; }
    [Parameter] public string Placeholder { get; set; } = "Select an item...";
    [Parameter] public string CssClass { get; set; } = "";
    [Parameter] public bool IsDisabled { get; set; } = false;
    [Parameter] public bool IsReadOnly { get; set; } = false;
    [Parameter] public bool IsInvalid { get; set; } = false;
    [Parameter] public bool AllowClear { get; set; } = true;
    [Parameter] public int PageSize { get; set; } = 20;
    [Parameter] public Func<string, Task<IEnumerable<TItem>>>? SearchFunction { get; set; }

    private string searchTerm = "";
    private bool isLoading = false;
    private int displayCount = 20;
    private IEnumerable<TItem> filteredItems = Enumerable.Empty<TItem>();
    private System.Timers.Timer? debounceTimer;

    protected override void OnInitialized()
    {
        debounceTimer = new System.Timers.Timer(300);
        debounceTimer.Elapsed += OnSearchDebounced;
        debounceTimer.AutoReset = false;

        FilterItems();
    }

    protected override void OnParametersSet()
    {
        FilterItems();
    }

    private async void OnSearchDebounced(object? sender, ElapsedEventArgs e)
    {
        await InvokeAsync(async () =>
        {
            await PerformSearch();
            StateHasChanged();
        });
    }

    private async Task PerformSearch()
    {
        if (SearchFunction != null && !string.IsNullOrWhiteSpace(searchTerm))
        {
            isLoading = true;
            try
            {
                var searchResults = await SearchFunction(searchTerm);
                filteredItems = searchResults;
                displayCount = PageSize;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Search error: {ex.Message}");
                filteredItems = Enumerable.Empty<TItem>();
            }
            finally
            {
                isLoading = false;
            }
        }
        else
        {
            FilterItems();
        }
    }

    private void FilterItems()
    {
        if (Items == null)
        {
            filteredItems = Enumerable.Empty<TItem>();
            return;
        }

        if (string.IsNullOrWhiteSpace(searchTerm))
        {
            filteredItems = Items;
        }
        else
        {
            filteredItems = Items.Where(item =>
            DisplaySelector(item).Contains(searchTerm, StringComparison.OrdinalIgnoreCase));
        }

        displayCount = PageSize;
    }

    private async Task SelectItem(TItem item)
    {
        var value = ValueSelector(item);
        SelectedValue = value;
        await SelectedValueChanged.InvokeAsync(value);
        StateHasChanged();
    }

    private async Task ClearSelection()
    {
        SelectedValue = default(TValue);
        await SelectedValueChanged.InvokeAsync(default(TValue));
        FilterItems();
        StateHasChanged();
    }

    private void LoadMore()
    {
        displayCount = Math.Min(displayCount + PageSize, filteredItems.Count());
        StateHasChanged();
    }

    public void Dispose()
    {
        debounceTimer?.Dispose();
    }
}
